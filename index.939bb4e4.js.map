{"mappings":"ujBAGE,IAIMA,EAAAA,EAmBA,WAGN,IAAIC,EAAO,KAGPC,EAAkB,GAGtBC,IAGA,IAAIC,EAAc,GAEdJ,EAAc,SAAUK,GAM1B,QAAqBC,KAJrBD,EAAUA,GAAW,IAITJ,MAAuC,OAAjBI,EAAQJ,MAAiBI,EAAQJ,OAASM,SAASF,EAAQJ,KAAM,IACjGA,EAAOI,EAAQJ,UAGV,GAA4B,iBAAjBI,EAAQJ,KACxBA,EAAOO,EAAgBH,EAAQJ,UAG1B,CAAA,QAAqBK,IAAjBD,EAAQJ,MAAuC,OAAjBI,EAAQJ,KAC/C,MAAM,IAAIQ,UAAU,+CAIpBR,EAAO,KAGT,IAAIS,EAAEC,EAGN,GAAsB,OAAlBN,EAAQO,YAAoCN,IAAlBD,EAAQO,MAAqB,CAKzD,IAHA,IAAIC,EAAcR,EAAQO,MACtBE,EAAS,GAEJC,EAAI,EAAGA,EAAIV,EAAQO,MAAOG,IACjCX,EAAYY,MAAK,GAInB,IAFAX,EAAQO,MAAQ,KAETC,EAAcC,EAAOG,QAAQ,CAElC,IAAIC,EAAQlB,EAAYK,GAEX,OAATJ,IACFI,EAAQJ,KAAOA,GAGjBa,EAAOE,KAAKE,GAKd,OAFAb,EAAQO,MAAQC,EAETC,EAaT,OAAOK,EAAU,CATjBT,EAAIU,EAAQf,GAGZM,EAAIU,EAAeX,EAAGL,GAGlBiB,EAAeZ,EAAGC,EAAGN,IAGCA,IAG5B,SAASe,EAAQf,GACf,GAAID,EAAYa,OAAS,EAAG,CAC1B,IAEIM,EAAMC,EAFNC,EAAWC,EAAgBrB,EAAQkB,MAKnCI,GAAQF,EAAS,GAAKA,EAAS,IAAMrB,EAAYa,OAEjDW,EAAIrB,UAAUgB,EAAME,EAAS,IAAME,GAkBvC,OAfuB,IAAnBvB,EAAYwB,GACdA,GAAKA,EAAI,GAAKxB,EAAYa,OAG1Bb,EAAYwB,IAAK,GAQnBL,EAAMC,EAFNC,EAAW,EAHAA,EAAS,GAAKG,EAAID,GAAQ,KAC1BF,EAAS,IAAMG,EAAI,GAAKD,GAAQ,OAMjC,IAAIJ,EAAM,IAAMA,GACnBA,EAGP,IAAIE,EASJ,OAPAF,EAAMC,EAFFC,EAAWI,EAAYxB,EAAQkB,OAKzB,IACRA,EAAM,IAAMA,GAGPA,EAIX,SAASF,EAAgBE,EAAKlB,GAE5B,GAAoB,eAAhBA,EAAQkB,IACV,OAAO,EAGT,GAA2B,WAAvBlB,EAAQyB,WACV,OAAON,EAAa,CAAC,EAAE,MAGzB,IAAIO,EAAkBC,EAAmBT,GAErCU,EAAOF,EAAgB,GACvBG,EAAOH,EAAgB,GAE3B,OAAQ1B,EAAQyB,YAEd,IAAK,SACHG,EAAO,GACP,MAEF,IAAK,OACHA,EAAOC,EAAO,GACd,MAEF,IAAK,QACHA,EAAO,GAIX,OAAOV,EAAa,CAACS,EAAMC,IAI7B,SAASZ,EAAgBZ,EAAGC,EAAGN,GAE7B,IAAI8B,EAAOC,EAAqB1B,EAAGC,GAC/B0B,EAAO,IAEX,OAAQhC,EAAQyB,YAEd,IAAK,OACHO,EAAOF,EAAO,GACd,MAEF,IAAK,QACHA,GAAQE,EAAOF,GAAM,EACrB,MAEF,IAAK,SACHA,EAAO,EACPE,EAAO,IAIX,OAAOb,EAAa,CAACW,EAAME,IAG7B,SAASlB,EAAWmB,EAAKjC,GAEvB,OAAQA,EAAQkC,QAEd,IAAK,WACH,OAAOD,EAET,IAAK,WACH,OAAOE,EAASF,GAElB,IAAK,MACH,IAAIG,EAAMD,EAASF,GACnB,MAAO,OAAOG,EAAI,GAAG,KAAKA,EAAI,GAAG,MAAMA,EAAI,GAAG,KAEhD,IAAK,OACH,IAAIC,EAAWF,EAASF,GACpBK,EAAQtC,EAAQsC,OAASC,KAAKC,SAClC,MAAO,QAAQH,EAAS,GAAG,KAAKA,EAAS,GAAG,MAAMA,EAAS,GAAG,MAAQC,EAAQ,IAEhF,IAAK,WACH,OAAOG,EAASR,GAElB,IAAK,MAEH,MAAO,OADGQ,EAASR,GACCS,KAAK,MAAQ,IAEnC,IAAK,OACH,IAAIC,EAAWF,EAASR,GAExB,OADIK,EAAQtC,EAAQsC,OAASC,KAAKC,SAC3B,QAAUG,EAASD,KAAK,MAAQ,KAAOJ,EAAQ,IAExD,QACE,OAAOM,EAASX,IAKtB,SAASF,EAAqB1B,EAAGC,GAI/B,IAFA,IAAIuC,EAAcC,EAAazC,GAAGwC,YAEzBnC,EAAI,EAAGA,EAAImC,EAAYjC,OAAS,EAAGF,IAAK,CAE/C,IAAIqC,EAAKF,EAAYnC,GAAG,GACpBsC,EAAKH,EAAYnC,GAAG,GAEpBuC,EAAKJ,EAAYnC,EAAE,GAAG,GACtBwC,EAAKL,EAAYnC,EAAE,GAAG,GAE1B,GAAIJ,GAAKyC,GAAMzC,GAAK2C,EAAI,CAErB,IAAIE,GAAKD,EAAKF,IAAKC,EAAKF,GAGxB,OAAOI,EAAE7C,GAFD0C,EAAKG,EAAEJ,IAOpB,OAAO,EAGT,SAASvB,EAAa4B,GAEpB,GAAoC,iBAAzBlD,SAASkD,GAA0B,CAE5C,IAAIC,EAASnD,SAASkD,GAEtB,GAAIC,EAAS,KAAOA,EAAS,EAC3B,MAAO,CAACA,EAAQA,GAKpB,GAA0B,iBAAfD,EAET,GAAIvD,EAAgBuD,GAAa,CAC/B,IAAIvC,EAAQhB,EAAgBuD,GAC5B,GAAIvC,EAAMO,SAAW,OAAOP,EAAMO,cAC7B,GAAIgC,EAAWE,MAAK,kCAAoC,CAC7D,IAAIpC,EAAMqC,EAASH,GAAY,GAC/B,MAAO,CAAElC,EAAKA,GAIlB,MAAO,CAAC,EAAE,KAIZ,SAASS,EAAoBT,GAC3B,OAAO4B,EAAa5B,GAAKQ,gBAG3B,SAASoB,EAAc5B,GAOrB,IAAK,IAAIsC,KAJLtC,GAAO,KAAOA,GAAO,MACvBA,GAAM,KAGcrB,EAAiB,CACpC,IAAIgB,EAAQhB,EAAgB2D,GAC5B,GAAI3C,EAAMO,UACNF,GAAOL,EAAMO,SAAS,IACtBF,GAAOL,EAAMO,SAAS,GACvB,OAAOvB,EAAgB2D,GAE3B,MAAO,kBAGX,SAASrC,EAAcsC,GACrB,GAAa,OAAT7D,EAAe,CAEjB,IAAI8D,EAAe,iBACfC,EAAEpB,KAAKC,SAGX,OAFAmB,GAAKD,EACLC,GAAK,EACEpB,KAAKqB,MAAMH,EAAM,GAAKE,GAAGF,EAAM,GAAK,EAAIA,EAAM,KAGrD,IAAII,EAAMJ,EAAM,IAAM,EAClBK,EAAML,EAAM,IAAM,EAElBM,GADJnE,GAAe,KAAPA,EAAc,OAAS,QACd,OACjB,OAAO2C,KAAKqB,MAAME,EAAMC,GAAOF,EAAMC,IAIzC,SAASlB,EAAUX,GAEjB,IAAI+B,EAAMvB,EAASR,GAEnB,SAASgC,EAAeC,GACpB,IAAIC,EAAMD,EAAEE,SAAS,IACrB,OAAqB,GAAdD,EAAIvD,OAAc,IAAMuD,EAAMA,EAKzC,MAFU,IAAMF,EAAeD,EAAI,IAAMC,EAAeD,EAAI,IAAMC,EAAeD,EAAI,IAMvF,SAASK,EAAaC,EAAMlD,EAAUyB,GAEpC,IAAIjB,EAAOiB,EAAY,GAAG,GACtBhB,EAAOgB,EAAYA,EAAYjC,OAAS,GAAG,GAE3CkB,EAAOe,EAAYA,EAAYjC,OAAS,GAAG,GAC3CoB,EAAOa,EAAY,GAAG,GAE1BhD,EAAgByE,GAAQ,CACtBlD,SAAUA,EACVyB,YAAaA,EACbnB,gBAAiB,CAACE,EAAMC,GACxB0C,gBAAiB,CAACzC,EAAME,IAK5B,SAASlC,IAEPuE,EACE,aACA,KACA,CAAC,CAAC,EAAE,GAAG,CAAC,IAAI,KAGdA,EACE,MACA,EAAC,GAAI,IACL,CAAC,CAAC,GAAG,KAAK,CAAC,GAAG,IAAI,CAAC,GAAG,IAAI,CAAC,GAAG,IAAI,CAAC,GAAG,IAAI,CAAC,GAAG,IAAI,CAAC,GAAG,IAAI,CAAC,GAAG,IAAI,CAAC,IAAI,MAGzEA,EACE,SACA,CAAC,GAAG,IACJ,CAAC,CAAC,GAAG,KAAK,CAAC,GAAG,IAAI,CAAC,GAAG,IAAI,CAAC,GAAG,IAAI,CAAC,GAAG,IAAI,CAAC,GAAG,IAAI,CAAC,IAAI,MAGzDA,EACE,SACA,CAAC,GAAG,IACJ,CAAC,CAAC,GAAG,KAAK,CAAC,GAAG,IAAI,CAAC,GAAG,IAAI,CAAC,GAAG,IAAI,CAAC,GAAG,IAAI,CAAC,GAAG,IAAI,CAAC,GAAG,IAAI,CAAC,IAAI,MAGjEA,EACE,QACA,CAAC,GAAG,KACJ,CAAC,CAAC,GAAG,KAAK,CAAC,GAAG,IAAI,CAAC,GAAG,IAAI,CAAC,GAAG,IAAI,CAAC,GAAG,IAAI,CAAC,GAAG,IAAI,CAAC,GAAG,IAAI,CAAC,IAAI,MAGjEA,EACE,OACA,CAAC,IAAK,KACN,CAAC,CAAC,GAAG,KAAK,CAAC,GAAG,IAAI,CAAC,GAAG,IAAI,CAAC,GAAG,IAAI,CAAC,GAAG,IAAI,CAAC,GAAG,IAAI,CAAC,GAAG,IAAI,CAAC,GAAG,IAAI,CAAC,IAAI,MAGzEA,EACE,SACA,CAAC,IAAK,KACN,CAAC,CAAC,GAAG,KAAK,CAAC,GAAG,IAAI,CAAC,GAAG,IAAI,CAAC,GAAG,IAAI,CAAC,GAAG,IAAI,CAAC,GAAG,IAAI,CAAC,GAAG,IAAI,CAAC,GAAG,IAAI,CAAC,IAAI,MAGzEA,EACE,OACA,CAAC,IAAK,KACN,CAAC,CAAC,GAAG,KAAK,CAAC,GAAG,IAAI,CAAC,GAAG,IAAI,CAAC,GAAG,IAAI,CAAC,GAAG,IAAI,CAAC,GAAG,IAAI,CAAC,IAAI,MAK3D,SAAS5B,EAAUR,GAIjB,IAAIuC,EAAIvC,EAAI,GACF,IAANuC,IAAUA,EAAI,GACR,MAANA,IAAYA,EAAI,KAGpBA,GAAM,IACN,IAAIC,EAAIxC,EAAI,GAAG,IACXyC,EAAIzC,EAAI,GAAG,IAEX0C,EAAMpC,KAAKqB,MAAQ,EAAFY,GACnBI,EAAQ,EAAJJ,EAAQG,EACZE,EAAIH,GAAK,EAAID,GACbK,EAAIJ,GAAK,EAAIE,EAAEH,GACfM,EAAIL,GAAK,GAAK,EAAIE,GAAGH,GACrBd,EAAI,IACJqB,EAAI,IACJC,EAAI,IAEN,OAAON,GACL,KAAK,EAAGhB,EAAIe,EAAGM,EAAID,EAAGE,EAAIJ,EAAI,MAC9B,KAAK,EAAGlB,EAAImB,EAAGE,EAAIN,EAAGO,EAAIJ,EAAI,MAC9B,KAAK,EAAGlB,EAAIkB,EAAGG,EAAIN,EAAGO,EAAIF,EAAI,MAC9B,KAAK,EAAGpB,EAAIkB,EAAGG,EAAIF,EAAGG,EAAIP,EAAI,MAC9B,KAAK,EAAGf,EAAIoB,EAAGC,EAAIH,EAAGI,EAAIP,EAAI,MAC9B,KAAK,EAAGf,EAAIe,EAAGM,EAAIH,EAAGI,EAAIH,EAI5B,MADa,CAACvC,KAAKqB,MAAQ,IAAFD,GAAQpB,KAAKqB,MAAQ,IAAFoB,GAAQzC,KAAKqB,MAAQ,IAAFqB,IAIjE,SAAS1B,EAAUY,GAEjBA,EAAqB,KADrBA,EAAMA,EAAIe,QAAO,KAAO,KACdtE,OAAeuD,EAAIe,QAAO,OAAS,QAAUf,EAEvD,IAAIgB,EAAMjF,SAASiE,EAAIiB,OAAO,EAAG,GAAI,IAAM,IACrCC,EAAQnF,SAASiE,EAAIiB,OAAO,EAAG,GAAI,IAAM,IACzCE,EAAOpF,SAASiE,EAAIiB,OAAO,EAAG,GAAI,IAAM,IAE1CG,EAAOhD,KAAKsB,IAAIsB,EAAKE,EAAOC,GAC1BE,EAAQD,EAAOhD,KAAKuB,IAAIqB,EAAKE,EAAOC,GACpCG,EAAaF,EAAQC,EAAQD,EAAQ,EAE3C,OAAQA,GACN,KAAKJ,EAAK,MAAO,EAAUE,EAAQC,GAAQE,EAAS,EAAjC,IAAuC,EAAGC,EAAYF,GACzE,KAAKF,EAAO,MAAO,CAAE,KAAQC,EAAOH,GAAOK,EAAS,IAAM,EAAGC,EAAYF,GACzE,KAAKD,EAAM,MAAO,CAAE,KAAQH,EAAME,GAASG,EAAS,IAAM,EAAGC,EAAYF,IAI7E,SAASpD,EAAUF,GACjB,IAAIuC,EAAIvC,EAAI,GACVwC,EAAIxC,EAAI,GAAG,IACXyC,EAAIzC,EAAI,GAAG,IACXyD,GAAK,EAAEjB,GAAGC,EAEZ,MAAO,CACLF,EACAjC,KAAKoD,MAAMlB,EAAEC,GAAKgB,EAAE,EAAIA,EAAI,EAAEA,GAAK,KAAS,IAC5CA,EAAE,EAAI,KAIV,SAASvF,EAAiByF,GAExB,IADA,IAAIC,EAAQ,EACHnF,EAAI,EAAGA,IAAMkF,EAAOhF,UACvBiF,GAASC,OAAOC,kBADerF,IAEnCmF,GAASD,EAAOI,WAAWtF,GAE7B,OAAOmF,EAIT,SAASxE,EAAgB4E,GACvB,GAAKC,MAAMD,IAON,GAAwB,iBAAbA,EAEd,GAAIpG,EAAgBoG,GAAW,CAC7B,IAAIpF,EAAQhB,EAAgBoG,GAE5B,GAAIpF,EAAMO,SACR,OAAOP,EAAMO,cAEZ,GAAI6E,EAAS3C,MAAK,kCAErB,OAAOR,EADGS,EAAS0C,GAAU,IACJ7E,aAjBP,CACtB,IAAIiC,EAASnD,SAAS+F,GAEtB,GAAI5C,EAAS,KAAOA,EAAS,EAC3B,OAAOP,EAAamD,GAAU7E,SAiBhC,MAAO,CAAC,EAAE,KAEZ,OAAOzB,EA/fawG,GAGgBC,GAAUA,EAAOC,UACjDA,EAAUD,EAAOC,QAAU1G,GAI7B0G,EAAQ1G,YAAcA,KCVnB,MAAM2G,EAAe,SAAsBC,GAChD,IAAiCC,EAAgBC,EAA7CC,EAAeH,EAAM3F,OAGzB,KAAO,IAAM8F,GAEXD,EAAclE,KAAKqB,MAAMrB,KAAKC,SAAWkE,GACzCA,GAAgB,EAGhBF,EAAiBD,EAAMG,GACvBH,EAAMG,GAAgBH,EAAME,GAC5BF,EAAME,GAAeD,EAGvB,OAAOD,GCFF,MAAMI,EAiCXC,QACEC,KAAKC,WAAaD,KAAKE,sBAAsBF,KAAKG,cAAcC,MAChEJ,KAAKK,UAAYL,KAAKK,UAAUC,OAAON,KAAKO,oBAC5CP,KAAKK,UAAYZ,EAAaO,KAAKK,WACnCL,KAAKQ,qBAAqBR,KAAK7G,QAAQsH,8BAA+BT,KAAK7G,QAAQuH,wBACnFV,KAAKW,wBACLX,KAAKY,2BAGPC,WACEb,KAAKC,WAAa,EAClBD,KAAKK,UAAY,GACjBL,KAAKc,sBACLC,OAAOC,oBAAoB,QAAShB,KAAKiB,2BACzCF,OAAOC,oBAAoB,OAAQhB,KAAKkB,kCACxCC,SAASH,oBAAoBhB,KAAKoB,sBAAuBpB,KAAKqB,yBAC9DrB,KAAKsB,SAASC,aACdvB,KAAKwB,QAGPtB,sBAAsBuB,GACpB,IAAIC,EAAaD,EAASE,wBAE1B,GAAKD,EAIL,OAAOA,EAAWE,OAASF,EAAWG,MAGxCC,sBAAsBC,GACpB,OAAOrG,KAAKsG,GAAKtG,KAAKoD,MAAMiD,GAAUrG,KAAKoD,MAAMiD,GAGnDE,mCAAmCC,EAAWC,GAC5C,OAAQD,EAAYC,EAAc,IAGpCC,+BAA+BC,GAC7B,IAAKrC,KAAKsC,gBAAgBvI,OACxB,OAAO,EAGT,IAAIwI,EAAmBvC,KAAKsC,gBACzBE,QAAOC,GAAUA,EAAOrC,KAAKsC,aAAa,UAAYL,IACtDM,KAAIF,GAAUzC,KAAK8B,sBAAsBzI,SAASoJ,EAAOG,KAAK,SAC9DC,QAAO,CAACC,EAAUC,IAAaD,EAAWC,GAAU,GAEvD,OAAO/C,KAAKiC,mCAAmCM,EAAkBvC,KAAKC,YAAc,GAGtFO,qBAAqBwC,EAAuB,EAAGC,EAAW,KAExDjD,KAAKkD,gBAAgBF,GAErBhD,KAAKmD,oBAAoBC,IAAIC,aAAY,IAAMrD,KAAKkD,gBAAgBF,IAAuBC,IAG7FnC,sBACE,IAAK,IAAImC,KAAYjD,KAAKmD,oBACxBpC,OAAOuC,cAAcL,GACrBjD,KAAKmD,oBAAoBI,OAAON,GAIpCtC,wBACEX,KAAKiB,0BAA4BjB,KAAKQ,qBAAqBgD,KAAKxD,MAChEA,KAAKkB,iCAAmC,KACtClB,KAAKwB,QACLxB,KAAKc,uBAEPd,KAAKqB,wBAA0BrB,KAAKyD,mBAAmBD,KAAKxD,MAG5De,OAAO2C,iBAAiB,QAAS1D,KAAKiB,2BACtCF,OAAO2C,iBAAiB,OAAQ1D,KAAKkB,kCAGrCC,SAASuC,iBAAiB1D,KAAKoB,sBAAuBpB,KAAKqB,yBAG7DoC,qBACEzD,KAAKwB,QAEDL,SAASnB,KAAK2D,yBAAwD,WAA7BxC,SAASyC,gBACpD5D,KAAKc,sBAELd,KAAKQ,uBAITI,2BACOG,OAAO8C,uBAIZ7D,KAAKsB,SAAW,IAAIuC,sBAAqB,CAACC,EAASxC,KACjDwC,EAAQC,SAAQC,IACVA,EAAMC,mBAAqB,IAAOjE,KAAKsC,gBAAgBvI,QACzDiG,KAAKc,sBACLd,KAAKwB,SACIwC,EAAMC,kBAAoB,KAAQjE,KAAKsC,gBAAgBvI,QAChEiG,KAAKQ,4BAGR,CAAC0D,UAAW,CAAC,GAAK,MAErBlE,KAAKsB,SAAS6C,QAAQnE,KAAKG,cAAcC,OAO3CgE,aACE,OAAOpE,KAAK7G,QAAQkL,SAAWC,KAAKC,MAOtC/C,QACsC,IAAhCxB,KAAKsC,gBAAgBvI,QAKzBiG,KAAKsC,gBAAgByB,SAAQtB,IAE3BtB,SAASqD,cAAc,IAAM/B,EAAOG,KAAK,OAAO6B,YAElDzE,KAAKsC,gBAAkB,GACvBtC,KAAK0E,qBAAuB,GAT1B1E,KAAK0E,qBAAuB,EAiBhCC,sBAAsBC,EAAgB,CAACnC,KAAaA,IACd,IAAhCzC,KAAKsC,gBAAgBvI,OAKzBiG,KAAKsC,gBAAkBtC,KAAKsC,gBAAgBE,QAAOC,KAC7CmC,EAAcnC,KAIhBtB,SAASqD,cAAc,IAAM/B,EAAOG,KAAK,OAAO6B,UACzC,KAVTzE,KAAK0E,qBAAuB,EAmBhCG,cAAcC,GACZ9E,KACG+E,WAAWD,EAAiB,KAC5BE,MAAK,KAAM,OCxNYC,EDwNN,ICvNf,IAAIC,SAAQ,CAACC,EAASC,KACtBH,GAAgC,iBAAbA,GACtBI,IAAI,mCAGNC,YAAW,IAAMH,KAAWzJ,KAAK6J,IAAIN,OAN1B,IAAeA,KDyNvBD,MAAK,IAAMhF,KAAKwF,WAAWV,EAAiB,OAC5CE,MAAK,KAGJ,IAAIS,EAActE,SAASqD,cAAc,IAAMM,EAAgBlC,KAAK,OAEhE6C,GACFA,EAAYhB,SAIdzE,KAAKsC,gBAAgBoD,OAAO1F,KAAKsC,gBAAgBqD,QAAQb,GAAkB,MASjFC,WAAWD,EAAiBc,EAAe,KACzC,MAAMC,EAAgBnK,KAAKsB,IAAIgD,KAAKG,cAAcC,KAAK0F,YAAa9F,KAAKG,cAAcC,KAAK2F,cAAgB,KAE5G,OAAO,IAAIb,SAAQ,CAACC,EAASC,KAC3BN,EAAgBkB,QACd,CAEElJ,EAAG+I,GAELD,EACAK,KAAKC,WACL,IAAMf,EAAQL,QAUpBU,WAAWV,EAAiBc,EAAe,KACzC,OAAO,IAAIV,SAAQ,CAACC,EAASC,KAE3BN,EAAgBkB,QACd,CACEG,QAAS,GAEXP,EACAK,KAAKG,QACL,IAAMjB,EAAQL,QAMpBuB,YAAYC,GACVtG,KAAKsC,gBAAgBxI,KAAKwM,GAS5BC,2BACE,IAAIC,EAAkBxG,KAAKK,UAAUL,KAAK0E,qBAAuB,GAOjE,OALI1E,KAAK0E,sBAAyB1E,KAAKK,UAAUtG,OAAS,IACxDiG,KAAKK,UAAYZ,EAAaO,KAAKK,WACnCL,KAAK0E,qBAAuB,GAG1B1E,KAAKoC,+BAA+BoE,IACtCxG,KAAK0E,sBAAwB,EACtB1E,KAAKK,UAAUL,KAAK0E,qBAAuB,IAG7C8B,EAOTC,8BAEE,MAAMC,EAAe1G,KAAKG,cAAcC,KAAK2F,aACvCY,EAAc3G,KAAKG,cAAcC,KAAK0F,YAK5C,MAAO,CAHGpK,KAAKqB,MAAMrB,KAAKC,UAAagL,EAAc,EAAK,GAAK,GACrDjL,KAAKqB,MAAOrB,KAAKC,SAAW+K,EAAgB,GAAK,GAU7DxD,gBAAgBF,EAAuB,EAAG4D,EAAiB5G,KAAKyG,4BAA4BjD,KAAKxD,OAC/F,IAAK,IAAInG,EAAI,EAAGA,EAAImJ,EAAsBnJ,IAAK,CAE7C,MAAOgN,EAAGC,GAAKF,IAETG,EAAW/G,KAAKoE,aAEhB4C,EAAiBhH,KAAKG,cACzBsC,OAAOoE,EAAGC,EAAG,GACblE,KAAK,CACJqE,KAAMjH,KAAKuG,2BACXW,GAAIH,IAGR/G,KAAKqG,YAAYW,GACjBhH,KAAK6E,cAAcmC,IA3TvBG,YAAYhH,EAAeiH,EAAcjO,GACvC6G,KAAKG,cAAgBA,EACrBH,KAAKmD,oBAAsB,IAAIkE,IAC/BrH,KAAKC,WAAa,EAClBD,KAAKO,mBAAqB6G,EAC1BpH,KAAKsC,gBAAkB,GACvBtC,KAAKK,UAAY,GACjBL,KAAK0E,qBAAuB,EAC5B1E,KAAK7G,QAAU,CACbkL,SAAU,SACV3D,uBAAwB,IACxBD,8BAA+B,EAC/B6G,qBAAsB,IAExBtH,KAAK7G,QAAUoO,OAAOC,OAAOxH,KAAK7G,QAASA,GAC3C6G,KAAK2D,uBAAyB,SAC9B3D,KAAKoB,sBAAwB,wBAEE,IAApBD,SAASsG,QAClBzH,KAAK2D,uBAAyB,SAC9B3D,KAAKoB,sBAAwB,yBACS,IAAtBD,SAASuG,UACzB1H,KAAK2D,uBAAyB,WAC9B3D,KAAKoB,sBAAwB,2BACa,IAA1BD,SAASwG,eACzB3H,KAAK2D,uBAAyB,eAC9B3D,KAAKoB,sBAAwB,0BAG/BpB,KAAKD,0BE5CTgB,OAAO2C,iBAAiB,QAAQ,KAC9B,IAAI5D,EAAa8H,KAAK,iBAAkBC,EAAAC,EAAA,CAAY,CAAElN,WAAY,QAASlB,MAAO","sources":["node_modules/randomcolor/randomColor.js","assets/js/utilities/shuffles.js","assets/js/components/paintCircles.js","assets/js/utilities/sleep.js","assets/js/index.js"],"sourcesContent":["// randomColor by David Merfield under the CC0 license\n// https://github.com/davidmerfield/randomColor/\n\n;(function(root, factory) {\n\n  // Support CommonJS\n  if (typeof exports === 'object') {\n    var randomColor = factory();\n\n    // Support NodeJS & Component, which allow module.exports to be a function\n    if (typeof module === 'object' && module && module.exports) {\n      exports = module.exports = randomColor;\n    }\n\n    // Support CommonJS 1.1.1 spec\n    exports.randomColor = randomColor;\n\n  // Support AMD\n  } else if (typeof define === 'function' && define.amd) {\n    define([], factory);\n\n  // Support vanilla script loading\n  } else {\n    root.randomColor = factory();\n  }\n\n}(this, function() {\n\n  // Seed to get repeatable colors\n  var seed = null;\n\n  // Shared color dictionary\n  var colorDictionary = {};\n\n  // Populate the color dictionary\n  loadColorBounds();\n\n  // check if a range is taken\n  var colorRanges = [];\n\n  var randomColor = function (options) {\n\n    options = options || {};\n\n    // Check if there is a seed and ensure it's an\n    // integer. Otherwise, reset the seed value.\n    if (options.seed !== undefined && options.seed !== null && options.seed === parseInt(options.seed, 10)) {\n      seed = options.seed;\n\n    // A string was passed as a seed\n    } else if (typeof options.seed === 'string') {\n      seed = stringToInteger(options.seed);\n\n    // Something was passed as a seed but it wasn't an integer or string\n    } else if (options.seed !== undefined && options.seed !== null) {\n      throw new TypeError('The seed value must be an integer or string');\n\n    // No seed, reset the value outside.\n    } else {\n      seed = null;\n    }\n\n    var H,S,B;\n\n    // Check if we need to generate multiple colors\n    if (options.count !== null && options.count !== undefined) {\n\n      var totalColors = options.count,\n          colors = [];\n      // Value false at index i means the range i is not taken yet.\n      for (var i = 0; i < options.count; i++) {\n        colorRanges.push(false)\n        }\n      options.count = null;\n\n      while (totalColors > colors.length) {\n\n        var color = randomColor(options);\n\n        if (seed !== null) {\n          options.seed = seed;\n        }\n\n        colors.push(color);\n      }\n\n      options.count = totalColors;\n\n      return colors;\n    }\n\n    // First we pick a hue (H)\n    H = pickHue(options);\n\n    // Then use H to determine saturation (S)\n    S = pickSaturation(H, options);\n\n    // Then use S and H to determine brightness (B).\n    B = pickBrightness(H, S, options);\n\n    // Then we return the HSB color in the desired format\n    return setFormat([H,S,B], options);\n  };\n\n  function pickHue(options) {\n    if (colorRanges.length > 0) {\n      var hueRange = getRealHueRange(options.hue)\n\n      var hue = randomWithin(hueRange)\n\n      //Each of colorRanges.length ranges has a length equal approximatelly one step\n      var step = (hueRange[1] - hueRange[0]) / colorRanges.length\n\n      var j = parseInt((hue - hueRange[0]) / step)\n\n      //Check if the range j is taken\n      if (colorRanges[j] === true) {\n        j = (j + 2) % colorRanges.length\n      }\n      else {\n        colorRanges[j] = true\n           }\n\n      var min = (hueRange[0] + j * step) % 359,\n          max = (hueRange[0] + (j + 1) * step) % 359;\n\n      hueRange = [min, max]\n\n      hue = randomWithin(hueRange)\n\n      if (hue < 0) {hue = 360 + hue;}\n      return hue\n    }\n    else {\n      var hueRange = getHueRange(options.hue)\n\n      hue = randomWithin(hueRange);\n      // Instead of storing red as two seperate ranges,\n      // we group them, using negative numbers\n      if (hue < 0) {\n        hue = 360 + hue;\n      }\n\n      return hue;\n    }\n  }\n\n  function pickSaturation (hue, options) {\n\n    if (options.hue === 'monochrome') {\n      return 0;\n    }\n\n    if (options.luminosity === 'random') {\n      return randomWithin([0,100]);\n    }\n\n    var saturationRange = getSaturationRange(hue);\n\n    var sMin = saturationRange[0],\n        sMax = saturationRange[1];\n\n    switch (options.luminosity) {\n\n      case 'bright':\n        sMin = 55;\n        break;\n\n      case 'dark':\n        sMin = sMax - 10;\n        break;\n\n      case 'light':\n        sMax = 55;\n        break;\n   }\n\n    return randomWithin([sMin, sMax]);\n\n  }\n\n  function pickBrightness (H, S, options) {\n\n    var bMin = getMinimumBrightness(H, S),\n        bMax = 100;\n\n    switch (options.luminosity) {\n\n      case 'dark':\n        bMax = bMin + 20;\n        break;\n\n      case 'light':\n        bMin = (bMax + bMin)/2;\n        break;\n\n      case 'random':\n        bMin = 0;\n        bMax = 100;\n        break;\n    }\n\n    return randomWithin([bMin, bMax]);\n  }\n\n  function setFormat (hsv, options) {\n\n    switch (options.format) {\n\n      case 'hsvArray':\n        return hsv;\n\n      case 'hslArray':\n        return HSVtoHSL(hsv);\n\n      case 'hsl':\n        var hsl = HSVtoHSL(hsv);\n        return 'hsl('+hsl[0]+', '+hsl[1]+'%, '+hsl[2]+'%)';\n\n      case 'hsla':\n        var hslColor = HSVtoHSL(hsv);\n        var alpha = options.alpha || Math.random();\n        return 'hsla('+hslColor[0]+', '+hslColor[1]+'%, '+hslColor[2]+'%, ' + alpha + ')';\n\n      case 'rgbArray':\n        return HSVtoRGB(hsv);\n\n      case 'rgb':\n        var rgb = HSVtoRGB(hsv);\n        return 'rgb(' + rgb.join(', ') + ')';\n\n      case 'rgba':\n        var rgbColor = HSVtoRGB(hsv);\n        var alpha = options.alpha || Math.random();\n        return 'rgba(' + rgbColor.join(', ') + ', ' + alpha + ')';\n\n      default:\n        return HSVtoHex(hsv);\n    }\n\n  }\n\n  function getMinimumBrightness(H, S) {\n\n    var lowerBounds = getColorInfo(H).lowerBounds;\n\n    for (var i = 0; i < lowerBounds.length - 1; i++) {\n\n      var s1 = lowerBounds[i][0],\n          v1 = lowerBounds[i][1];\n\n      var s2 = lowerBounds[i+1][0],\n          v2 = lowerBounds[i+1][1];\n\n      if (S >= s1 && S <= s2) {\n\n         var m = (v2 - v1)/(s2 - s1),\n             b = v1 - m*s1;\n\n         return m*S + b;\n      }\n\n    }\n\n    return 0;\n  }\n\n  function getHueRange (colorInput) {\n\n    if (typeof parseInt(colorInput) === 'number') {\n\n      var number = parseInt(colorInput);\n\n      if (number < 360 && number > 0) {\n        return [number, number];\n      }\n\n    }\n\n    if (typeof colorInput === 'string') {\n\n      if (colorDictionary[colorInput]) {\n        var color = colorDictionary[colorInput];\n        if (color.hueRange) {return color.hueRange;}\n      } else if (colorInput.match(/^#?([0-9A-F]{3}|[0-9A-F]{6})$/i)) {\n        var hue = HexToHSB(colorInput)[0];\n        return [ hue, hue ];\n      }\n    }\n\n    return [0,360];\n\n  }\n\n  function getSaturationRange (hue) {\n    return getColorInfo(hue).saturationRange;\n  }\n\n  function getColorInfo (hue) {\n\n    // Maps red colors to make picking hue easier\n    if (hue >= 334 && hue <= 360) {\n      hue-= 360;\n    }\n\n    for (var colorName in colorDictionary) {\n       var color = colorDictionary[colorName];\n       if (color.hueRange &&\n           hue >= color.hueRange[0] &&\n           hue <= color.hueRange[1]) {\n          return colorDictionary[colorName];\n       }\n    } return 'Color not found';\n  }\n\n  function randomWithin (range) {\n    if (seed === null) {\n      //generate random evenly destinct number from : https://martin.ankerl.com/2009/12/09/how-to-create-random-colors-programmatically/\n      var golden_ratio = 0.618033988749895\n      var r=Math.random()\n      r += golden_ratio\n      r %= 1\n      return Math.floor(range[0] + r*(range[1] + 1 - range[0]));\n    } else {\n      //Seeded random algorithm from http://indiegamr.com/generate-repeatable-random-numbers-in-js/\n      var max = range[1] || 1;\n      var min = range[0] || 0;\n      seed = (seed * 9301 + 49297) % 233280;\n      var rnd = seed / 233280.0;\n      return Math.floor(min + rnd * (max - min));\n}\n  }\n\n  function HSVtoHex (hsv){\n\n    var rgb = HSVtoRGB(hsv);\n\n    function componentToHex(c) {\n        var hex = c.toString(16);\n        return hex.length == 1 ? '0' + hex : hex;\n    }\n\n    var hex = '#' + componentToHex(rgb[0]) + componentToHex(rgb[1]) + componentToHex(rgb[2]);\n\n    return hex;\n\n  }\n\n  function defineColor (name, hueRange, lowerBounds) {\n\n    var sMin = lowerBounds[0][0],\n        sMax = lowerBounds[lowerBounds.length - 1][0],\n\n        bMin = lowerBounds[lowerBounds.length - 1][1],\n        bMax = lowerBounds[0][1];\n\n    colorDictionary[name] = {\n      hueRange: hueRange,\n      lowerBounds: lowerBounds,\n      saturationRange: [sMin, sMax],\n      brightnessRange: [bMin, bMax]\n    };\n\n  }\n\n  function loadColorBounds () {\n\n    defineColor(\n      'monochrome',\n      null,\n      [[0,0],[100,0]]\n    );\n\n    defineColor(\n      'red',\n      [-26,18],\n      [[20,100],[30,92],[40,89],[50,85],[60,78],[70,70],[80,60],[90,55],[100,50]]\n    );\n\n    defineColor(\n      'orange',\n      [18,46],\n      [[20,100],[30,93],[40,88],[50,86],[60,85],[70,70],[100,70]]\n    );\n\n    defineColor(\n      'yellow',\n      [46,62],\n      [[25,100],[40,94],[50,89],[60,86],[70,84],[80,82],[90,80],[100,75]]\n    );\n\n    defineColor(\n      'green',\n      [62,178],\n      [[30,100],[40,90],[50,85],[60,81],[70,74],[80,64],[90,50],[100,40]]\n    );\n\n    defineColor(\n      'blue',\n      [178, 257],\n      [[20,100],[30,86],[40,80],[50,74],[60,60],[70,52],[80,44],[90,39],[100,35]]\n    );\n\n    defineColor(\n      'purple',\n      [257, 282],\n      [[20,100],[30,87],[40,79],[50,70],[60,65],[70,59],[80,52],[90,45],[100,42]]\n    );\n\n    defineColor(\n      'pink',\n      [282, 334],\n      [[20,100],[30,90],[40,86],[60,84],[80,80],[90,75],[100,73]]\n    );\n\n  }\n\n  function HSVtoRGB (hsv) {\n\n    // this doesn't work for the values of 0 and 360\n    // here's the hacky fix\n    var h = hsv[0];\n    if (h === 0) {h = 1;}\n    if (h === 360) {h = 359;}\n\n    // Rebase the h,s,v values\n    h = h/360;\n    var s = hsv[1]/100,\n        v = hsv[2]/100;\n\n    var h_i = Math.floor(h*6),\n      f = h * 6 - h_i,\n      p = v * (1 - s),\n      q = v * (1 - f*s),\n      t = v * (1 - (1 - f)*s),\n      r = 256,\n      g = 256,\n      b = 256;\n\n    switch(h_i) {\n      case 0: r = v; g = t; b = p;  break;\n      case 1: r = q; g = v; b = p;  break;\n      case 2: r = p; g = v; b = t;  break;\n      case 3: r = p; g = q; b = v;  break;\n      case 4: r = t; g = p; b = v;  break;\n      case 5: r = v; g = p; b = q;  break;\n    }\n\n    var result = [Math.floor(r*255), Math.floor(g*255), Math.floor(b*255)];\n    return result;\n  }\n\n  function HexToHSB (hex) {\n    hex = hex.replace(/^#/, '');\n    hex = hex.length === 3 ? hex.replace(/(.)/g, '$1$1') : hex;\n\n    var red = parseInt(hex.substr(0, 2), 16) / 255,\n          green = parseInt(hex.substr(2, 2), 16) / 255,\n          blue = parseInt(hex.substr(4, 2), 16) / 255;\n\n    var cMax = Math.max(red, green, blue),\n          delta = cMax - Math.min(red, green, blue),\n          saturation = cMax ? (delta / cMax) : 0;\n\n    switch (cMax) {\n      case red: return [ 60 * (((green - blue) / delta) % 6) || 0, saturation, cMax ];\n      case green: return [ 60 * (((blue - red) / delta) + 2) || 0, saturation, cMax ];\n      case blue: return [ 60 * (((red - green) / delta) + 4) || 0, saturation, cMax ];\n    }\n  }\n\n  function HSVtoHSL (hsv) {\n    var h = hsv[0],\n      s = hsv[1]/100,\n      v = hsv[2]/100,\n      k = (2-s)*v;\n\n    return [\n      h,\n      Math.round(s*v / (k<1 ? k : 2-k) * 10000) / 100,\n      k/2 * 100\n    ];\n  }\n\n  function stringToInteger (string) {\n    var total = 0\n    for (var i = 0; i !== string.length; i++) {\n      if (total >= Number.MAX_SAFE_INTEGER) break;\n      total += string.charCodeAt(i)\n    }\n    return total\n  }\n\n  // get The range of given hue when options.count!=0\n  function getRealHueRange(colorHue)\n  { if (!isNaN(colorHue)) {\n    var number = parseInt(colorHue);\n\n    if (number < 360 && number > 0) {\n      return getColorInfo(colorHue).hueRange\n    }\n  }\n    else if (typeof colorHue === 'string') {\n\n      if (colorDictionary[colorHue]) {\n        var color = colorDictionary[colorHue];\n\n        if (color.hueRange) {\n          return color.hueRange\n       }\n    } else if (colorHue.match(/^#?([0-9A-F]{3}|[0-9A-F]{6})$/i)) {\n        var hue = HexToHSB(colorHue)[0]\n        return getColorInfo(hue).hueRange\n    }\n  }\n\n    return [0,360]\n}\n  return randomColor;\n}));\n","/**\n * Shuffles an array with the knuth shuffling algo\n * @param {array} array an array holding any kind of data\n * @returns {object} the provided array, shuffled randomly\n */\nexport const shuffleArray = function shuffleArray(array) {\n  let currentIndex = array.length, temporaryValue, randomIndex;\n\n  // While there remain elements to shuffle...\n  while (0 !== currentIndex) {\n    // Pick a remaining element...\n    randomIndex = Math.floor(Math.random() * currentIndex);\n    currentIndex -= 1;\n\n    // And swap it with the current element.\n    temporaryValue = array[currentIndex];\n    array[currentIndex] = array[randomIndex];\n    array[randomIndex] = temporaryValue;\n  }\n\n  return array;\n}","import {shuffleArray} from '../utilities/shuffles.js';\nimport sleep from '../utilities/sleep.js';\n\n/**\n  Creates circles of a random color in a canvas continuously over time, that expand from nothing to a certain size, \n  till they cover enough of the canvas, at which point, the cycle begins again with circles of a new color.\n\n  Used for the splash animation. \n  Inspired by Spotify's year in rewind event sites.\n\n  * @param {object} templateSvgEl must be a valid Snap svg instance\n  * @param {array<string>} randomColors array of random color HEXs\n  * @param {string} options.idPrefix the prefix string to use for the sequentially generated IDs of the color splotches\n  * @param {number} options.generationIntervalInMs time to wait between circle generation\n  * @param {number} options.generationIntervalCircleCount # of circles to generate every interval\n  * @param {number} options.areaCoveredThreshold circles expand within the templateSvgEl until this % area is reached. Then the color is changed. (switch cycles)\n  * @returns {object} a PaintCircles instance with all its methods and properties, that can be instantiated just by calling the constructor\n  */\nexport class PaintCircles {\n  constructor(templateSvgEl, randomColors, options) {\n    this.templateSvgEl = templateSvgEl;\n    this.generationIntervals = new Set();\n    this.canvasArea = 0;\n    this.generatedHexColors = randomColors;\n    this.circlesInCanvas = [];\n    this.hexColors = [];\n    this.whichColorInSequence = 1;\n    this.options = {\n      idPrefix: 'circle',\n      generationIntervalInMs: 4000,\n      generationIntervalCircleCount: 1,\n      areaCoveredThreshold: 95,\n    };\n    this.options = Object.assign(this.options, options);\n    this.documentHiddenProperty = 'hidden';\n    this.visibilityChangeEvent = 'visibilitychange';\n    \n    if (typeof document.hidden !== 'undefined') {\n      this.documentHiddenProperty = 'hidden';\n      this.visibilityChangeEvent = 'visibilitychange';\n    } else if (typeof document.msHidden !== 'undefined') {\n      this.documentHiddenProperty = 'msHidden';\n      this.visibilityChangeEvent = 'msvisibilitychange';\n    } else if (typeof document.webkitHidden !== 'undefined') {\n      this.documentHiddenProperty = 'webkitHidden';\n      this.visibilityChangeEvent = 'webkitvisibilitychange';\n    }\n\n    this.setup();\n  }\n\n  setup() {\n    this.canvasArea = this.calculateAreaOfCanvas(this.templateSvgEl.node);\n    this.hexColors = this.hexColors.concat(this.generatedHexColors);\n    this.hexColors = shuffleArray(this.hexColors);\n    this.startGenerationClock(this.options.generationIntervalCircleCount, this.options.generationIntervalInMs);\n    this.bindWindowFocusSwitch();\n    this.bindIntersectionObserver();\n  }\n\n  teardown() {\n    this.canvasArea = 0;\n    this.hexColors = [];\n    this.stopGenerationClock();\n    window.removeEventListener('focus', this.boundStartGenerationClock);\n    window.removeEventListener('blur', this.boundCleanAndStopGenerationClock);\n    document.removeEventListener(this.visibilityChangeEvent, this.boundOnVisibilityChange);\n    this.observer.disconnect();\n    this.clean();\n  }\n\n  calculateAreaOfCanvas(canvasEl) {\n    let dimensions = canvasEl.getBoundingClientRect();\n\n    if (!dimensions) {\n      return;\n    }\n\n    return dimensions.height * dimensions.width;\n  }\n\n  calculateAreaOfCircle(radius) {\n    return Math.PI * Math.round(radius) * Math.round(radius);\n  }\n\n  calculatePercentageCoveredOfCanvas(childArea, parentArea) {\n    return (childArea / parentArea) * 100;\n  }\n\n  isEnoughOfCanvasCoveredByColor(hexColorToCheck) {\n    if (!this.circlesInCanvas.length) {\n      return false;\n    }\n\n    let roughAreaCovered = this.circlesInCanvas\n      .filter(circle => circle.node.getAttribute('fill') === hexColorToCheck)\n      .map(circle => this.calculateAreaOfCircle(parseInt(circle.attr('r'))))\n      .reduce((prevArea, currArea) => prevArea + currArea, 0);\n\n    return this.calculatePercentageCoveredOfCanvas(roughAreaCovered, this.canvasArea) > 95;\n  }\n\n  startGenerationClock(numCirclesToGenerate = 1, interval = 3000) {\n    // generate one circle immediately\n    this.generateCircles(numCirclesToGenerate);\n    // start generating circles every interval\n    this.generationIntervals.add(setInterval(() => this.generateCircles(numCirclesToGenerate), interval));\n  }\n\n  stopGenerationClock() {\n    for (let interval of this.generationIntervals) {\n      window.clearInterval(interval);\n      this.generationIntervals.delete(interval);\n    }\n  }\n\n  bindWindowFocusSwitch() {\n    this.boundStartGenerationClock = this.startGenerationClock.bind(this);\n    this.boundCleanAndStopGenerationClock = () => {\n      this.clean();\n      this.stopGenerationClock();\n    };\n    this.boundOnVisibilityChange = this.onVisibilityChange.bind(this);\n\n    // keep track of whether the browser tab or window is in focus. If not, pause animations and other background js processes for performance\n    window.addEventListener('focus', this.boundStartGenerationClock);\n    window.addEventListener('blur', this.boundCleanAndStopGenerationClock);\n\n    // NOTE: visiblity change API is currently buggy on Safari\n    document.addEventListener(this.visibilityChangeEvent, this.boundOnVisibilityChange);\n  }\n\n  onVisibilityChange() {\n    this.clean();\n\n    if (document[this.documentHiddenProperty] || document.visibilityState === 'hidden') {\n      this.stopGenerationClock(); \n    } else {\n      this.startGenerationClock();\n    }\n  }\n\n  bindIntersectionObserver() {\n    if (!window.IntersectionObserver) {\n      return;\n    }\n\n    this.observer = new IntersectionObserver((entries, observer) => { \n      entries.forEach(entry => {\n        if (entry.intersectionRatio <= 0.1 && this.circlesInCanvas.length){\n          this.stopGenerationClock();\n          this.clean();\n        } else if (entry.intersectionRatio > 0.1 && !this.circlesInCanvas.length) {\n          this.startGenerationClock();\n        }\n      });\n    }, {threshold: [0.1, 0.6]});\n\n    this.observer.observe(this.templateSvgEl.node);\n  }\n\n  /**\n   * Simple ID gen using current time\n   * @returns {string} a string that can be used as an element ID\n   */\n  generateID() {\n    return this.options.idPrefix + Date.now();\n  }\n  \n  /**\n   * Remove all circles\n   * @returns {void}\n   */\n  clean() {\n    if (this.circlesInCanvas.length === 0) {\n      this.whichColorInSequence = 1;\n      return;\n    }\n\n    this.circlesInCanvas.forEach(circle => {\n      // Remove svg from DOM\n      document.querySelector('#' + circle.attr('id')).remove();\n    });\n    this.circlesInCanvas = [];\n    this.whichColorInSequence = 1;\n  }\n\n  /**\n   * Remove circles that satisfy a condition\n   * @param {function} conditionFunc the circle Snap.svg object is passed as an argument\n   * @returns {void}\n   */\n  cleanBasedOnCondition(conditionFunc = (circle) => !!circle) {\n    if (this.circlesInCanvas.length === 0) {\n      this.whichColorInSequence = 1;\n      return;\n    }\n\n    this.circlesInCanvas = this.circlesInCanvas.filter(circle => {\n      if (conditionFunc(circle)) {\n        return true;\n      } else {\n        // Remove svg from DOM\n        document.querySelector('#' + circle.attr('id')).remove();\n        return false;\n      }\n    });\n  }\n\n  /**\n   * Animates a circle to grow, pause for a little while, fade out, then remove itself from local store and the DOM\n   * @param {object} snapSvgInstance \n   */\n  animateCircle(snapSvgInstance) {\n    this\n      .growCircle(snapSvgInstance, 10000)\n      .then(() => sleep(5000))\n      .then(() => this.fadeCircle(snapSvgInstance, 1000))\n      .then(() => {\n        // Then delete the instance completely from the DOM and store\n        // remove from DOM\n        let domInstance = document.querySelector('#' + snapSvgInstance.attr('id'));\n\n        if (domInstance) {\n          domInstance.remove();\n        }\n\n        // remove from storage\n        this.circlesInCanvas.splice(this.circlesInCanvas.indexOf(snapSvgInstance), 1);\n      });\n  }\n\n  /**\n   * Makes an SVG circle grow to fill the space of the templateSvgEl\n   * @param {object} snapSvgInstance valid Snap svg object\n   * @param {number} durationInMs how long should the animation happen for?\n   */\n  growCircle(snapSvgInstance, durationInMs = 10000) {\n    const sizeToScaleTo = Math.max(this.templateSvgEl.node.clientWidth, this.templateSvgEl.node.clientHeight) / 1.25;\n\n    return new Promise((resolve, reject) => {\n      snapSvgInstance.animate(\n        {\n          //target radius\n          r: sizeToScaleTo\n        },\n        durationInMs,\n        mina.easeInOut,\n        () => resolve(snapSvgInstance)\n      );\n    });\n  }\n\n  /**\n   * Makes a Snap SVG circle fade out\n   * @param {object} snapSvgInstance  valid Snap svg object\n   * @param {number} durationInMs how long should the animation happen for?\n   */\n  fadeCircle(snapSvgInstance, durationInMs = 1000) {\n    return new Promise((resolve, reject) => {\n      //Fade to 0 opacity after scale is complete\n      snapSvgInstance.animate(\n        {\n          opacity: 0\n        },\n        durationInMs,\n        mina.linear,\n        () => resolve(snapSvgInstance)\n      );\n    });\n  }\n\n  // store SVG object in store\n  storeCircle(snapSvgObj) {\n    this.circlesInCanvas.push(snapSvgObj);\n  }\n\n  /**\n   * Gets the current color in the color sequence, unless we're at the end of the sequence\n   * in which case we shuffle the sequence and start over. If enough of the canvas is covered with one color\n   * we increment to the next color in the sequence.\n   * @returns {string} HEX color\n   */\n  getSequentialRandomColor() {\n    let currentHexColor = this.hexColors[this.whichColorInSequence - 1];\n\n    if (this.whichColorInSequence >= (this.hexColors.length - 1)) {\n      this.hexColors = shuffleArray(this.hexColors);\n      this.whichColorInSequence = 1;\n    }\n\n    if (this.isEnoughOfCanvasCoveredByColor(currentHexColor)) {\n      this.whichColorInSequence += 1;\n      return this.hexColors[this.whichColorInSequence - 1];\n    }\n\n    return currentHexColor;\n  }\n\n  /**\n   * Get random viewport coordinates from the template SVG element\n   * @returns {array} x and y coordinate array\n   */\n  getRandomViewportCoordinate() {\n    //Extract viewport dimensions\n    const screenHeight = this.templateSvgEl.node.clientHeight;\n    const screenWidth = this.templateSvgEl.node.clientWidth;\n    //Assign random location\n    const x = Math.floor(Math.random() * ((screenWidth - 0) + 1) + 1);\n    const y = Math.floor((Math.random() * screenHeight) + 1) + 1;\n\n    return [x, y];\n  }\n\n  /**\n   * Generates circles at random coordinates specified by the getCoordinates function, stores them in local store, and animates them\n   * @param {number} numCirclesToGenerate the number of circles to generate\n   * @param {function} getCoordinates function that returns an x,y coordinate for the circle to be generated\n   */\n  generateCircles(numCirclesToGenerate = 3, getCoordinates = this.getRandomViewportCoordinate.bind(this)) {\n    for (let i = 0; i < numCirclesToGenerate; i++) {\n      //Coordinates for generation origin\n      const [x, y] = getCoordinates();\n      //Generate unique ID for every circle\n      const uniqueID = this.generateID();\n      //Create circle instance\n      const circleInstance = this.templateSvgEl\n        .circle(x, y, 1)\n        .attr({\n          fill: this.getSequentialRandomColor(),\n          id: uniqueID\n        });\n      \n      this.storeCircle(circleInstance);\n      this.animateCircle(circleInstance);\n    }\n  }\n}","export default function sleep(timeInMs) {\n  return new Promise((resolve, reject) => {\n    if (!timeInMs || typeof timeInMs !== 'number') {\n      rej('Invalid time argument provided.');\n    }\n\n    setTimeout(() => resolve(), Math.abs(timeInMs));\n  });\n}","'use strict';\r\nimport {PaintCircles} from './components/paintCircles.js';\r\nimport randomColor from 'randomcolor';\r\n\r\nwindow.addEventListener('load', () => {\r\n  new PaintCircles(Snap('#circleCanvas'), randomColor({ luminosity: 'light', count: 10 }));\r\n});"],"names":["randomColor","seed","colorDictionary","loadColorBounds","colorRanges","options","undefined","parseInt","stringToInteger","TypeError","H","S","count","totalColors","colors","i","push","length","color","setFormat","pickHue","pickSaturation","pickBrightness","hue","randomWithin","hueRange","getRealHueRange","step","j","getHueRange","luminosity","saturationRange","getSaturationRange","sMin","sMax","bMin","getMinimumBrightness","bMax","hsv","format","HSVtoHSL","hsl","hslColor","alpha","Math","random","HSVtoRGB","join","rgbColor","HSVtoHex","lowerBounds","getColorInfo","s1","v1","s2","v2","m","colorInput","number","match","HexToHSB","colorName","range","golden_ratio","r","floor","max","min","rnd","rgb","componentToHex","c","hex","toString","defineColor","name","brightnessRange","h","s","v","h_i","f","p","q","t","g","b","replace","red","substr","green","blue","cMax","delta","saturation","k","round","string","total","Number","MAX_SAFE_INTEGER","charCodeAt","colorHue","isNaN","factory","module","exports","$4db8787053ccad78$export$7ac3a88d34a76e7","array","temporaryValue","randomIndex","currentIndex","$b36a02580b61992f$export$284e66fa55303dd4","setup","this","canvasArea","calculateAreaOfCanvas","templateSvgEl","node","hexColors","concat","generatedHexColors","startGenerationClock","generationIntervalCircleCount","generationIntervalInMs","bindWindowFocusSwitch","bindIntersectionObserver","teardown","stopGenerationClock","window","removeEventListener","boundStartGenerationClock","boundCleanAndStopGenerationClock","document","visibilityChangeEvent","boundOnVisibilityChange","observer","disconnect","clean","canvasEl","dimensions","getBoundingClientRect","height","width","calculateAreaOfCircle","radius","PI","calculatePercentageCoveredOfCanvas","childArea","parentArea","isEnoughOfCanvasCoveredByColor","hexColorToCheck","circlesInCanvas","roughAreaCovered","filter","circle","getAttribute","map","attr","reduce","prevArea","currArea","numCirclesToGenerate","interval","generateCircles","generationIntervals","add","setInterval","clearInterval","delete","bind","onVisibilityChange","addEventListener","documentHiddenProperty","visibilityState","IntersectionObserver","entries","forEach","entry","intersectionRatio","threshold","observe","generateID","idPrefix","Date","now","querySelector","remove","whichColorInSequence","cleanBasedOnCondition","conditionFunc","animateCircle","snapSvgInstance","growCircle","then","timeInMs","Promise","resolve","reject","rej","setTimeout","abs","fadeCircle","domInstance","splice","indexOf","durationInMs","sizeToScaleTo","clientWidth","clientHeight","animate","mina","easeInOut","opacity","linear","storeCircle","snapSvgObj","getSequentialRandomColor","currentHexColor","getRandomViewportCoordinate","screenHeight","screenWidth","getCoordinates","x","y","uniqueID","circleInstance","fill","id","constructor","randomColors","Set","areaCoveredThreshold","Object","assign","hidden","msHidden","webkitHidden","Snap","$parcel$interopDefault","$eb4JW"],"version":3,"file":"index.939bb4e4.js.map"}